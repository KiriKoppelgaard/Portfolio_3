---
title: "A4_P2_CoordinatingHeartRate"
author: "Kiri Koppelgaard"
date: "November 16, 2018"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup2, include = FALSE}
setwd("~/Cognitive Science/3. Semester/Experimental Methods 3/Portfolio 3/CleanData2018/")

library(pacman)
p_load(tidyverse, stringr, Metrics, caret, lme4, simr, lmerTest, stats, FinCal, PerformanceAnalytics, nonlinearTseries, GMCM, pROC, groupdata2, gridExtra, crqa, graphics, ggbeeswarm)
```

## Analysing Heart Rate and Respiration data

The goal of this assignment is to first familiarize you with heart rate, and respiration data and their preprocessing. The second part explores how to analyze interpersonal coordination of these signals.

These are the questions you need to be able to answer at the end of the assignment (aka that you need to submit as part of the portfolio)

#1) How do you preprocess heart rate and respiration data? Describe the process. If any data needs to be excluded, list the excluded data and motivate the exclusion.

The amount of inquired data from the experiment was very large. Therefore in order to make it more managable, we downsampled  the data.  We grouped the original data by 100, found the mean and used this “new data point” further in the analysis. The downsampling did not affect the data in large scale, as the plots below show

```{r plotting raw data and downsampled data for one pair, echo = FALSE}

#creating read function
set.seed(1)
read_data <- function(filename) {
#read data  
  participant <- read.csv(filename, header = TRUE)
#parse filename; study, diagnosis, subject, trial
  name = str_match(filename,"Study(\\d+)_G(\\d+)_T(\\d+)_([:alpha:]+)")
  clinical = as.data.frame(t(name[2:length(name)]))
  names(clinical) = c("study","group","trial", "condition")
#downsampling
  data = participant %>%
  group(n = 100, method = 'greedy') %>%
  dplyr::summarise(
  time = mean(TimeMs,na.rm=T),
  HR1 = mean(HR1,na.rm=T),
  HR2 = mean(HR2,na.rm=T),
  Resp1 = mean(Resp1,na.rm=T),
  Resp2 = mean(Resp2,na.rm=T))
#combine all this data
return(cbind(clinical, data))
}
setwd("~/Cognitive Science/3. Semester/Experimental Methods 3/Portfolio 3/CleanData2018/")

#loading raw data for one pair
r_data <- read_data("Study3_G2_T2_Synchronous.csv")
r_plot <- ggplot(r_data, aes(time, HR1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Raw data") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")


#loading downsampled data
p_data <- read.csv("cleaned_data2018.csv")

p_data<- p_data[-1] #remove the x column

#plotting one pair
group2_synchronous <- filter(p_data, group == 2 & condition == "Synchronous")

p_plot <- ggplot(group2_synchronous, aes(time, HR1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Downsampled") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")

grid.arrange(r_plot, p_plot)

```

All the downsampled data is plotted below for each group in each condition: 

```{r plotting downsampled data, echo = FALSE}

p_data = group_by(p_data, condition, group) %>% mutate(time = time - min(time))

#HEART RATE
HR_D <- ggplot(p_data, aes(time, HR1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Heart Rate") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")
HR_D

#RESPIRATION
Resp_D <- ggplot(p_data, aes(time, Resp1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Respiration") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")
Resp_D
```


Second, we scaled the data using the scale function. It calculates the mean and standard deviation of the entire vector, then "scale" each element by those values by subtracting the mean and dividing by the sd. This was in order to correct the data from different baselines. Below are all groups in each condition scaled

```{r scaling1 , include = FALSE}
#scaling the measures and making them numeric
p_data$Resp1=as.numeric(scale(p_data$Resp1))
p_data$Resp2=as.numeric(scale(p_data$Resp2))
p_data$HR1=as.numeric(scale(p_data$HR1))
p_data$HR2=as.numeric(scale(p_data$HR2))
```


```{r making a plot with scaled data, include = FALSE}
p_data = group_by(p_data, condition, group) %>% mutate(time = time - min(time))

#HEART RATE
HR_D <- ggplot(p_data, aes(time, HR1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Heart Rate") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")
HR_D

#RESPIRATION
Resp_D <- ggplot(p_data, aes(time, Resp1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Respiration") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")
Resp_D
```


Third, we removed outliers. We made a function (i.e. Riccardo made a function), that replaces a data point with the mean, if the data point is bigger than or smaller than the mean  a threshold*standard deviation. The threshold was selected by trial-and-error - we inspected the plots. 


```{r removing outliers 1, include = FALSE}

#creating an removing outlier function
removeOuts <- function(ts,threshold){
ts[ts > (mean(ts,na.rm=T) +
(threshold*sd(ts,na.rm=T))) |
ts < (mean(ts,na.rm=T)-(threshold*sd(ts,na.rm=T)))] = mean(ts,na.rm=T)
return(ts)
}

#defining the threshold
threshold=1.5

#removing the outliers from the measures
p_data$HR1=removeOuts(p_data$HR1,threshold)
p_data$HR2=removeOuts(p_data$HR2,threshold)
p_data$Resp1=removeOuts(p_data$Resp1,threshold)
p_data$Resp2=removeOuts(p_data$Resp2,threshold)

```

Here is a plot of the results: 

```{r making a plot with scaled and outlier removed data, echo = FALSE}
p_data = group_by(p_data, condition, group) %>% mutate(time = time - min(time))

#HEART RATE
HR_D <- ggplot(p_data, aes(time, HR1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Heart Rate") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")
HR_D

#RESPIRATION
Resp_D <- ggplot(p_data, aes(time, Resp1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Respiration") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")
Resp_D
```


Finally, we plot ALL the data to inspect if something looks “weird”, e.g. a participant is flatlining. After inspecting the plots, we decided to exclude group 9’s condition “Synchronous” since one participant in the group flatlines in this condition.


#2) Do you observe interpersonal coordination in heart rate and respiration? Describe your control baseline, the method used to quantify coordination, and the statistical models used to infer whether coordination was higher than in the baseline. Report the results of the models.

We created two baselines: shuffled and surrogate. 
  - shuffled; take a timeseries and rearrange its values in a random order
    - the numbers randomly versus the numbers in a specific order (the difference between)
  - surrogate; matching one of the participants, with somebody doing the same task, but in a different pair
    - being in the room versus the same task (the difference between)

We used CRQA to quantify coordination selecting the crqa indexes: RR, L, DET (herefrom refered to as the crqa parameters). RR is a measure of the proportion of similar values in the timeseries, DET is a measure how easy it is to predict the next datapoint from the timeseries. L is a measure for how long the two timeseries tend to recur. 

```{r models to test interpersonal coordination, include = FALSE}
setwd("~/Cognitive Science/3. Semester/Experimental Methods 3/Portfolio 3/CleanData2018/")

crqa_results_Resp <- read.csv("crqa_results_Resp.csv")
crqa_results_HR <- read.csv("crqa_results_HR.csv")


#model testing if there is a difference between real and shuffled pairs

#HR
model_real_shuffled_RR = lm(RR ~pair_type, data = crqa_results_HR)
summary(model_real_shuffled_RR)

model_real_shuffled_L = lm(L ~pair_type, data = crqa_results_HR)
summary(model_real_shuffled_L)

model_real_shuffled_DET = lm(DET ~pair_type, data = crqa_results_HR)
summary(model_real_shuffled_DET)

#RESP
model_real_shuffled_RR = lm(RR ~pair_type, data = crqa_results_Resp)
summary(model_real_shuffled_RR)

model_real_shuffled_L = lm(L ~pair_type, data = crqa_results_Resp)
summary(model_real_shuffled_L)

model_real_shuffled_DET = lm(DET ~pair_type, data = crqa_results_Resp)
summary(model_real_shuffled_DET)
```


Performing a linear fixed effect analysis where the various crqa parameters is predicted by the pair type e.g. RR ~pair_type using both respiration data and heart rate data, respectively.

When investigating the effect of type of pair i.e. shuffled, surrogate or real on the crqa parameter RR (RR ~pair_type) using the heart rate data. We find, that shuffled pairs are not significantly different from real pairs in predicting how similair the values in the two  timeseries are (p > 0.05). This is rather different effect than we espected, since this indicates the RR measure of recurrence might have been the same amount due to chance, time has no effect. However, it appears that real pairs are significantly different from surrogate pairs, which is a measure of the effect of being in the same room (p < 0.05). However, if the real pairs are not significantly different from the shuffled pairs i.e. the effect might as well be due to chance, it makes little sense to investigate the effect of being in the same room together. 

```{r plots 2 RR HR, echo = FALSE}
#HR RR
HRRR <- ggplot(crqa_results_HR, aes(pair_type, RR)) + geom_quasirandom(alpha = 0.5, colour = "forestgreen") + labs(x = "Pair type", y = "Parameter value", title = "RR") + geom_boxplot(alpha = 0.5)+ 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
HRRR
```

When investigating the effect of type of pair i.e. shuffled, surrogate or real on the crqa parameter L (L ~pair_type) using the heart rate data. We find, that both shuffled pairs and surrogate pairs are significantly different from the real pair (p<0.05). This supports the hypothesis of interpersonal coordination in heart rate at least in the aspect of  for how long the two timeseries tend to recur.  

```{r plots 2 L HR,  echo = FALSE}
#HR L
HRL <- ggplot(crqa_results_HR,aes(pair_type, L)) + geom_quasirandom(alpha = 0.5, colour = "blue") + labs(x = "Pair type", y = "Parameter value", title = "L") + geom_boxplot(alpha = 0.5)+ 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
HRL
```

Investigating the effect of pair type on the crqa parameter DET (DET ~pair_type) using the heart rate data, we found that the real pairs was significantly different from shuffled pairs (p < 0.05). Thus, the recurrence does not occur simply due to chance, however, we find no effect of the fact, that the pair is in the same room together, since surrogate pairs does not significantly differ from real pairs (p> 0.05). 


```{r plots 2 DET HR, echo = FALSE}
#HR DET
HRDET <- ggplot(crqa_results_HR,aes(pair_type, DET)) + geom_quasirandom(alpha = 0.5, colour = "blue") + labs(x = "Pair type", y = "Parameter value", title = "L") + geom_boxplot(alpha = 0.5)+ 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
HRL
```

Investigating the effect of pair type on the crqa parameter RR (RR~pair_type) using the respiration data, we find similar results, as when we investigated the effect pair type on the crqa parameter RR using the heart rate data. We find, that shuffled pairs are not significantly different from real pairs in predicting how similair the values in the two  timeseries are (p > 0.05), though, it appears that real pairs are significantly different from surrogate pairs, which is a measure of the effect of being in the same room (p < 0.05). However as mentioned, if the real pairs are not significantly different from the shuffled pairs i.e. the effect might as well be due to chance, it makes little sense to investigate the effect of being in the same room together. 

```{r plots 2 RR Resp,  echo = FALSE}

#Resp RR
RespRR <- ggplot(crqa_results_Resp, aes(pair_type, RR)) + geom_quasirandom(alpha = 0.5, colour = "forestgreen") + labs(x = "Pair type", y = "Parameter value", title = "RR") + geom_boxplot(alpha = 0.5)+ 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
RespRR

```


Investigating the effect of pair type on the crqa parameter L (L~pair_type) using the respiration data, we find that neither shuffled pairs or surrogate pairs are significantly different from the real pairs (p>0.05). This suggests, there is no  interpersonal coordination, when measuring how long the two timeseries tend to recur. 

```{r plots 2 L Resp, echo = FALSE}

#Resp L
RespL <- ggplot(crqa_results_Resp,aes(pair_type, L)) + geom_quasirandom(alpha = 0.5, colour = "blue") + labs(x = "Pair type", y = "Parameter value", title = "L") + geom_boxplot(alpha = 0.5)+ 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
RespL

```

Investigating the effect of pair type on the crqa parameter DET (DET ~pair_type) using the respiration data, we found that the real pairs was significantly different from shuffled pairs (p < 0.05). Thus, the recurrence does not occur simply due to chance, however, we find no effect of the fact, that the pair is in the same room together, since surrogate pairs does not significantly differ from real pairs (p> 0.05). This is similar to the result we found using the heart rate data. 

```{r plots 2 DET Resp, echo = FALSE}
#Resp DET
RespDET <- ggplot(crqa_results_Resp, aes(pair_type, DET)) + geom_quasirandom(alpha = 0.5, colour = "red") + labs(x = "Pair type", y = "Parameter value", title = "DET") + geom_boxplot(alpha = 0.5)+ 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
RespDET

```


Thus, we have elements of interpersonal coordination in heart rate and respiration, though the effect can be questioned. 

#3) Do you observe differences in coordination between conditions? Report the models and results.

We tested the coordination between the condition applying a model, where the crqa parameters are predicted by the interaction between pair type and condition for both the heart rate data and the respiration data e.g. RR ~ condition * pair_type

None of the models have significant interaction effects between condition and pair type. This implicates that the coordination does not differ as an effect of pair type in the different conditions. 

The lack interaction effect can also be seen in the plot below. 

```{r interaction models, include = FALSE}
#making a model
modelRR_HR = lm(RR ~ condition * pair_type, data = crqa_results_HR)
summary(modelRR_HR)

modelL_HR = lm(L ~ condition * pair_type, data = crqa_results_HR)
summary(modelL_HR)

modelDET_HR = lm(DET ~ condition*pair_type, data = crqa_results_HR)
summary(modelDET_HR)

#pair_typeshuffled                       -93.0478     3.6657 -25.383   <2e-16

#making a model
modelRR_Resp = lm(RR ~ condition * pair_type, data = crqa_results_Resp)
summary(modelRR_Resp)

modelL_Resp = lm(L ~ condition * pair_type, data = crqa_results_Resp)
summary(modelL_Resp)

modelDET_Resp = lm(DET ~ condition*pair_type, data = crqa_results_Resp)
summary(modelDET_Resp)

#pair_typeshuffled                        -67.814      9.094  -7.457 4.33e-13
```


```{r plots 3, echo = FALSE}
#Respiration 

#Resp DET
predictions = crqa_results_Resp %>%
  distinct(condition, pair_type) %>%
  cbind(predict(modelDET_Resp, newdata = ., interval = "confidence")) 

RespDET <- ggplot(crqa_results_Resp, aes(pair_type, DET)) + 
  geom_quasirandom(alpha = 0.5, colour = "dark red") + 
  labs(x = "Pair type", y = "Parameter value", title = "DET") + 
  #geom_boxplot(alpha = 0.5) +p
  geom_point(aes(y = fit), data = predictions, size = 3) +
  geom_errorbar(aes(y = NULL, ymin = lwr, ymax = upr), data = predictions, width = .3) +
  facet_wrap(~condition) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))


#Resp RR
predictions = crqa_results_Resp %>%
  distinct(condition, pair_type) %>%
  cbind(predict(modelRR_Resp, newdata = ., interval = "confidence")) 

RespRR <- ggplot(crqa_results_Resp, aes(pair_type, RR)) + 
  geom_quasirandom(alpha = 0.5, colour = "dark red") + 
  labs(x = "Pair type", y = "Parameter value", title = "RR") + 
  #geom_boxplot(alpha = 0.5) +p
  geom_point(aes(y = fit), data = predictions, size = 3) +
  geom_errorbar(aes(y = NULL, ymin = lwr, ymax = upr), data = predictions, width = .3) +
  facet_wrap(~condition) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))


#Resp L
predictions = crqa_results_Resp %>%
  distinct(condition, pair_type) %>%
  cbind(predict(modelL_Resp, newdata = ., interval = "confidence")) 

RespL <- ggplot(crqa_results_Resp, aes(pair_type, L)) + 
  geom_quasirandom(alpha = 0.5, colour = "dark red") + 
  labs(x = "Pair type", y = "Parameter value", title = "L") + 
  #geom_boxplot(alpha = 0.5) +p
  geom_point(aes(y = fit), data = predictions, size = 3) +
  geom_errorbar(aes(y = NULL, ymin = lwr, ymax = upr), data = predictions, width = .3) +
  facet_wrap(~condition) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

grid.arrange(RespL,RespRR,RespDET, top = 'Respiration', ncol=3)

#Heart rate
#HR DET
predictions = crqa_results_HR %>%
  distinct(condition, pair_type) %>%
  cbind(predict(modelDET_HR, newdata = ., interval = "confidence")) 


HRDET <- ggplot(crqa_results_HR, aes(pair_type, DET)) + 
  geom_quasirandom(alpha = 0.5, colour = "dark red") + 
  labs(x = "Pair type", y = "Parameter value", title = "DET") + 
  #geom_boxplot(alpha = 0.5) +p
  geom_point(aes(y = fit), data = predictions, size = 3) +
  geom_errorbar(aes(y = NULL, ymin = lwr, ymax = upr), data = predictions, width = .3) +
  facet_wrap(~condition) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

#HR RR
predictions = crqa_results_HR %>%
  distinct(condition, pair_type) %>%
  cbind(predict(modelRR_HR, newdata = ., interval = "confidence")) 


HRRR <- ggplot(crqa_results_HR, aes(pair_type, RR)) + 
  geom_quasirandom(alpha = 0.5, colour = "dark red") + 
  labs(x = "Pair type", y = "Parameter value", title = "RR") + 
  #geom_boxplot(alpha = 0.5) +p
  geom_point(aes(y = fit), data = predictions, size = 3) +
  geom_errorbar(aes(y = NULL, ymin = lwr, ymax = upr), data = predictions, width = .3) +
  facet_wrap(~condition) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

#HR L
predictions = crqa_results_HR %>%
  distinct(condition, pair_type) %>%
  cbind(predict(modelL_HR, newdata = ., interval = "confidence")) 


HRL <- ggplot(crqa_results_HR, aes(pair_type, L)) + 
  geom_quasirandom(alpha = 0.5, colour = "dark red") + 
  labs(x = "Pair type", y = "Parameter value", title = "L") + 
  #geom_boxplot(alpha = 0.5) +p
  geom_point(aes(y = fit), data = predictions, size = 3) +
  geom_errorbar(aes(y = NULL, ymin = lwr, ymax = upr), data = predictions, width = .3) +
  facet_wrap(~condition) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

grid.arrange(HRL,HRRR,HRDET, top = 'HR', ncol=3)

```


4) Is respiration coordination a likely driver of heart rate coordination? Describe how you would test for it. Bonus points if you actually run the tests and report methods and results.

To test whether respiration coordination is a likely dirver of heart rate coordination, we would like to gather crqa results for heart rate and respiration in one dataframe paired by groups. 

The model, which could be used to investigate the question could look something like this: modelCoor_RR <- lm(RR(HR) ~ RR(Resp)*pair_type)

N.B. Because of the timing, we're starting this exercise before collecting the data.
Instead, you will develop your script this week on data from two years ago (Study1) and last year (Study2).
When you hand in the assignment for feedback, you can use the old data. But when you hand in the final version for the exam, you need to adapt your script to use the data we collect next week in the lab.
(For the old data): Note that synchronouns and turn-taking are the same task across both studies, but the third condition is different: two years ago it was self-paced joint reading; last year it was tv-series conversation.

NB: For this exercise, you will need to do something very similiar to what you've done before spread over several weeks. Ie parse data, look at the plots, decide on data cleaning, build a model, and finally evaluate and interpret the results of the models. Going back and copying the approach from previous exercises will likely be a great help.

```{r loading data, include = FALSE}

setwd("~/Cognitive Science/3. Semester/Experimental Methods 3/Portfolio 3/CleanData2018/")
set.seed(1)
read_data <- function(filename) {
#read data  
  participant <- read.csv(filename, header = TRUE)
#parse filename; study, diagnosis, subject, trial
  name = str_match(filename,"Study(\\d+)_G(\\d+)_T(\\d+)_([:alpha:]+)")
  clinical = as.data.frame(t(name[2:length(name)]))
  names(clinical) = c("study","group","trial", "condition")
#downsampling
  data = participant %>%
  group(n = 100, method = 'greedy') %>%
  dplyr::summarise(
  time = mean(TimeMs,na.rm=T),
  HR1 = mean(HR1,na.rm=T),
  HR2 = mean(HR2,na.rm=T),
  Resp1 = mean(Resp1,na.rm=T),
  Resp2 = mean(Resp2,na.rm=T))
#combine all this data
return(cbind(clinical, data))
}

# when you've created a function that works, you can
#p_data = list.files() %>% map_df(read_data)

#write.csv(p_data, file = "cleaned_data2018.csv")
 
p_data <- read.csv("cleaned_data2018.csv")

p_data<- p_data[-1] #remove the x column
```


## Step by step suggestions to solve the assignment

### Exploring physiological signals

- Choose one pair (one pair, three conditions)
```{r exploring data, include = FALSE, echo= FALSE}
#HEARTRATE
#Filtering the data
pair5_S <- filter(p_data, group == 5, condition == "Synchronous")
pair5_TT <- filter(p_data, group == 5, condition == "TurnTaking")
pair5_C <- filter(p_data, group == 5, condition == "Conversation")

#plotting the pairs in each condition
plot1 <- ggplot(pair5_S, aes(time)) + 
  geom_line(aes(y = HR1, colour = "HR1")) + 
  geom_line(aes(y = HR2, colour = "HR2")) + ggtitle("Synchronous")

plot2 <- ggplot(pair5_TT, aes(time)) + 
  geom_line(aes(y = HR1, colour = "HR1")) + 
  geom_line(aes(y = HR2, colour = "HR2")) + ggtitle("TurnTaking")

plot3 <- ggplot(pair5_C, aes(time)) + 
  geom_line(aes(y = HR1, colour = "HR1")) + 
  geom_line(aes(y = HR2, colour = "HR2")) + ggtitle("Conversation")

#Plotting them side by side
plot5_HR <- grid.arrange(plot1,plot2,plot3)

#Respiration
pair5_S <- filter(p_data, group == 5, condition == "Synchronous")
pair5_TT <- filter(p_data, group == 5, condition == "TurnTaking")
pair5_C <- filter(p_data, group == 5, condition == "Conversation")

plot1 <- ggplot(pair5_S, aes(time)) + 
  geom_line(aes(y = Resp1, colour = "Resp1")) + 
  geom_line(aes(y = Resp2, colour = "Resp2")) + ggtitle("Synchronous")

plot2 <- ggplot(pair5_TT, aes(time)) + 
  geom_line(aes(y = Resp1, colour = "Resp1")) + 
  geom_line(aes(y = Resp2, colour = "Resp2")) + ggtitle("TurnTaking")

plot3 <- ggplot(pair5_C, aes(time)) + 
  geom_line(aes(y = Resp1, colour = "Resp1")) + 
  geom_line(aes(y = Resp2, colour = "Resp2")) + ggtitle("Conversation")

#Plotting them side by side
plot5_Resp <- grid.arrange(plot1,plot2,plot3)

 
```


```{r scaling, include = FALSE}
#scaling the measures and making them numeric
p_data$Resp1=as.numeric(scale(p_data$Resp1))
p_data$Resp2=as.numeric(scale(p_data$Resp2))
p_data$HR1=as.numeric(scale(p_data$HR1))
p_data$HR2=as.numeric(scale(p_data$HR2))
```


```{r removing outliers, include = FALSE}

#creating an removing outlier function
removeOuts <- function(ts,threshold){
ts[ts > (mean(ts,na.rm=T) +
(threshold*sd(ts,na.rm=T))) |
ts < (mean(ts,na.rm=T)-(threshold*sd(ts,na.rm=T)))] = mean(ts,na.rm=T)
return(ts)
}

#defining the threshold
threshold=1.5

#removing the outliers from the measures
p_data$HR1=removeOuts(p_data$HR1,threshold)
p_data$HR2=removeOuts(p_data$HR2,threshold)
p_data$Resp1=removeOuts(p_data$Resp1,threshold)
p_data$Resp2=removeOuts(p_data$Resp2,threshold)

```

```{r making a plot with processed data, include = FALSE}
p_data = group_by(p_data, condition, group) %>% mutate(time = time - min(time))

#HEART RATE
HR_D <- ggplot(p_data, aes(time, HR1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Heart Rate") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")
HR_D

#RESPIRATION
Resp_D <- ggplot(p_data, aes(time, Resp1)) + geom_line(aes(y = Resp1, colour = "1")) +
  geom_line(aes(y = Resp2, colour = "2")) + ggtitle("Respiration") + labs(x = "Time", y = "Respiration", colour = "Participant") + facet_grid(group ~ condition, scales = "free")
Resp_D
```



```{r checking the processed data, include = FALSE, echo = FALSE, eval = FALSE}
#checking how the plot looks now
pair5_S <- filter(p_data, group == 1, study == 1, condition == "Synchronous")
pair5_TT <- filter(p_data, group == 1, study == 1, condition == "TurnTaking")
pair5_SP <- filter(p_data, group == 1, study == 1, condition == "Conversation")


plot5_S <- ggplot(pair5_S, aes(time)) + 
  geom_line(aes(y = HR1, colour = "HR1")) + 
  geom_line(aes(y = HR2, colour = "HR2")) + ggtitle("Synchronous")

plot5_TT <- ggplot(pair5_TT, aes(time)) + 
  geom_line(aes(y = HR1, colour = "HR1")) + 
  geom_line(aes(y = HR2, colour = "HR2")) + ggtitle("TurnTaking")

plot5_SP <- ggplot(pair5_SP, aes(time)) + 
  geom_line(aes(y = HR1, colour = "HR1")) + 
  geom_line(aes(y = HR2, colour = "HR2")) + ggtitle("Conversation")

#plot5_HR <- grid.arrange(plot5_S,plot5_TT,plot5_SP)

#checking how the plot looks now
pair5_S <- filter(p_data, group == 1, study == 1, condition == "Synchronous")
pair5_TT <- filter(p_data, group == 1, study == 1, condition == "TurnTaking")
pair5_SP <- filter(p_data, group == 1, study == 1, condition == "Conversation")


plot5_S <- ggplot(pair5_S, aes(time)) + 
  geom_line(aes(y = Resp1, colour = "Resp1")) + 
  geom_line(aes(y = Resp2, colour = "Resp2")) + ggtitle("Synchronous")

plot5_TT <- ggplot(pair5_TT, aes(time)) + 
  geom_line(aes(y = Resp1, colour = "Resp1")) + 
  geom_line(aes(y = Resp2, colour = "Resp2")) + ggtitle("TurnTaking")

plot5_SP <- ggplot(pair5_SP, aes(time)) + 
  geom_line(aes(y = Resp1, colour = "Resp1")) + 
  geom_line(aes(y = Resp2, colour = "Resp2")) + ggtitle("Conversation")

#grid.arrange(plot5_S,plot5_TT,plot5_SP)

#plot5_Resp <- grid.arrange(plot5_S,plot5_TT,plot5_SP)

```

- Load the logs
- Produce a plot of the participants' respiration signal and a different one of the participants' HR signal (for inspecting whether the data is usable)
  N.B: remember the slides: artifacts, downsampling, scaling.
  N.B. The gridExtra::grid.arrange() function allows you to display the plots side by side. E.g. grid.arrange(plot1, plot2, plot3, ncol=3)
  
- Can you eye-ball which condition if any displays more physiological coordination?

  RESPONSE: 
  The synchronous condition for respiration is the most synchronous, since they follow whenever one of the jumps. 
  The turntaking condition for heartrate, when one go up, the other one goes down. 
  
- Run crqa on heart rate and respiration data (find parameters, run crqa)
```{r crqa on a single pair, include = FALSE, eval = FALSE}
p_data <- na.omit(p_data)

#Heart rate
pair5_S <- filter(p_data, group == 5, condition == "Synchronous")
pair5_TT <- filter(p_data, group == 5, condition == "TurnTaking")
pair5_C <- filter(p_data, group == 5, condition == "Conversation")

#Finding the optimal parameters
par = list(lgM = 50, steps = seq(1, 6, 1), radiusspan = 100, radiussample = 40, normalize = 0, rescale = 0, mindiagline = 2, minvertline = 2, tw = 0, whiteline =
FALSE, recpt = FALSE, fnnpercent = 10, typeami = "mindip")

ans = optimizeParam(pair5_C$HR1, pair5_C$HR2, par, min.rec = 3.5, max.rec = 4.5)

Results=crqa (pair5_C$HR1, pair5_C$HR2, delay=delay, embed=embdim, radius=radius,normalize=0,rescale=0,mindiagline = 2,minvertline = 2)

#Representing the plot
RP = Results$RP
RP = matrix(as.numeric(RP), nrow = ncol(RP))
cols = c("white","blue4")
image(RP, xlab = "", ylab = "", col = cols)

#explore the lags of coordination
Profile=drpdfromts(pair1$HR1, pair1$HR2,datatype = 'continuous',ws=50,radius=radius)
timecourse = round( seq(-5000,5000,100)/1000, digit = 1)
maxlag = Profile$maxlag/1000
profile = Profile$profile*100
Prof=data.frame(profile)
ggplot(Prof, aes(timecourse,profile))+geom_line()+ geom_vline(xintercept = timecourse[maxlag], colour='red')


```
- Does this tell you more than just eyeballing the plots?

RESPONSE: Yes, this quantifies the plots, thus making them easier to compare. 

### Systematically pre-process the data
- Loop through all the files (either with a loop or with a function), check which files should be excluded, if any, and save the pre-processed time-series. Tip: plot and visually inspect the data to figure out which should be excluded
```{r exploring the data, include = FALSE, eval = FALSE}
#Heartrate plot
for (i in unique(p_data$group)){
  pair_S <- filter(p_data, group == i, condition == "Synchronous")
  pair_TT <- filter(p_data, group == i, condition == "TurnTaking")
  pair_C <- filter(p_data, group == i,condition == "Conversation")
  ggplot(pair_S, aes(time)) + 
    geom_line(aes(y = HR1, colour = "HR1")) + 
    geom_line(aes(y = HR2, colour = "HR2")) + ggtitle("Synchronous")
  ggplot2::ggsave(file = paste('plot_S', i, '.pdf', sep = ""), path = "plots/HR")
  ggplot(pair_TT, aes(time)) + 
    geom_line(aes(y = HR1, colour = "HR1")) + 
    geom_line(aes(y = HR2, colour = "HR2")) + ggtitle("TurnTaking")
  ggplot2::ggsave(file = paste('plot_TT', i, '.pdf', sep = ""), path = "plots/HR")
  ggplot(pair_C, aes(time)) + 
    geom_line(aes(y = HR1, colour = "HR1")) + 
    geom_line(aes(y = HR2, colour = "HR2")) + ggtitle("Conversation")
  ggplot2::ggsave(file = paste('plot_C', i, '.pdf', sep = ""), path = "plots/HR")
}

#Respiration
for (i in unique(p_data$group)){
  pair_S <- filter(p_data, group == i, condition == "Synchronous")
  pair_TT <- filter(p_data, group == i, condition == "TurnTaking")
  pair_C <- filter(p_data, group == i,condition == "Conversation")
  ggplot(pair_S, aes(time)) + 
    geom_line(aes(y = Resp1, colour = "Resp1")) + 
    geom_line(aes(y = Resp2, colour = "Resp2")) + ggtitle("Synchronous")
  ggplot2::ggsave(file = paste('plot_S', i, '.pdf', sep = ""), path = "plots/Resp")
  ggplot(pair_TT, aes(time)) + 
    geom_line(aes(y = Resp1, colour = "Resp1")) + 
    geom_line(aes(y = Resp2, colour = "Resp2")) + ggtitle("TurnTaking")
  ggplot2::ggsave(file = paste('plot_TT', i, '.pdf', sep = ""), path = "plots/Resp")
  ggplot(pair_C, aes(time)) + 
    geom_line(aes(y = Resp1, colour = "Resp1")) + 
    geom_line(aes(y = Resp2, colour = "Resp2")) + ggtitle("Conversation")
  ggplot2::ggsave(file = paste('plot_C', i, '.pdf', sep = ""), path = "plots/Resp")
}
```


```{r excluding data, include = FALSE, eval = FALSE}
p_data <- subset(p_data, !(condition == 'Synchronous' & group ==9))
```


```{r choosing optimal parameters, include = FALSE, eval = FALSE}

#making an extra unique group and and condition
p_data <- p_data %>%
  mutate(group_condition = str_c(group, condition, sep = " "))

group_condition_list <- unique(p_data$group_condition)

#running par
par = list(lgM = 50, steps = seq(1, 6, 1), radiusspan = 100, radiussample = 40, normalize = 0, rescale = 0, mindiagline = 2, minvertline = 2, tw = 0, whiteline =
FALSE, recpt = FALSE, fnnpercent = 10, typeami = "mindip")

#Heartrate
hr_params=NULL

for (groupcondition in group_condition_list){
  print("start")
  HR = filter(p_data, group_condition == groupcondition) #choosing data for the specific group in the specific condition
  print(nrow(HR))
  ans=NULL #getting the ANS variable started
  try(expr = ans <- #finding optimal parameters
      optimizeParam(ts(HR$HR1),
                    ts(HR$HR2),
                    par,
                    min.rec = 2,
                    max.rec = 5))
  if (length(ans)==0){ #if no optimal parameter insert NA
    radius=NA
    delay=NA
    emddim=NA
  } else{ #otherwiseassign the values
  radius = ans[[1]]
  emddim = ans[[2]]
  delay = ans[[3]]
  }
  if (exists("hr_params")){ #if the second or more input rbind to these
    hr_params = rbind(hr_params, data.frame(radius, emddim, delay))
  } else { #otherwise create the dataframe
    hr_params = data.frame(radius, emddim, delay)
  }
}

#write csv
#write.csv(hr_params, file = "hr_params2018.csv")

#omitting na's
hr_params <- na.omit(hr_params)

#defining global parameters
radiusHR = 1.23 #median(hr_params$radius): Altering the value to get an occurrence rate close to 4
emddimHR = median(hr_params$emddim)
delayHR = median(hr_params$delay)

#Respiration
resp_params=NULL

for (groupcondition in group_condition_list){
  print("start")
  resp = filter(p_data, group_condition == groupcondition)
  print(nrow(resp))
  ans=NULL
  try(expr = ans <-
      optimizeParam(ts(resp$Resp1),
                    ts(resp$Resp2),
                    par,
                    min.rec = 2,
                    max.rec = 5))
  if (length(ans)==0){
    radius=NA
    delay=NA
    emddim=NA
  } else{
  radius = ans[[1]]
  emddim = ans[[2]]
  delay = ans[[3]]
  }
  if (exists("resp_params")){
    resp_params = rbind(resp_params, data.frame(radius, emddim, delay))
  } else {
    resp_params = data.frame(radius, emddim, delay)
  }
}

#omitting na's
resp_params <- na.omit(resp_params)

#defining global parameters
radiusResp = 0.1 #altering to get a better reoccurence rate median(resp_params$radius)
emddimResp = median(resp_params$emddim)
delayResp = median(resp_params$delay)

#write csv
#write.csv(resp_params, file = "resp_params2018.csv")

```

- Run crqa on all the pre-processed time-series and save the output (don't forget to add columns with study, group, condition and trial). Tip: remember to first assess optimal parameters (dimensions, delay, radius) across all timeseries. 

Tip: it will often fail, just take whatever parameters you get, select optimal across timeseries parameters and run crqa on all timeseries with those. Tip: double check the rr. When I ran the loop, I got very low rr, so I adjusted the radius until the average of rr across all pairs was approx. 4%.

```{r crqa loop real pairs, include = FALSE, eval = FALSE}
#HEARTRATE
pairs <- unique(p_data$group_condition) #defining list with paiirs in each condition
result_df <- NULL

# Loop for HR 
for (i in pairs){
  currentpair = filter(p_data,group_condition==i) #select data
  Results=crqa(currentpair$HR1, currentpair$HR2, delay=delayHR, embed=emddimHR, radius=radiusHR, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2) #run crqa
  temp_df <- data_frame(group_trial = unique(currentpair$group_condition),study = unique(currentpair$study),group = unique(currentpair$group),trial = unique(currentpair$trial),condition = unique(currentpair$condition), RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT) #extracting results
  # study = currentpair$study,group = currentpair$group, trial = currentpair$trial, condition = currentpair$condition, 
if (i == 1){
    result_df <- temp_df #if the first iteration temporary df == result df
  } else {
    result_df <- rbind(result_df, temp_df) #if second or more iteration rbind to existing dataframe
  }
}

result_real_HR <- result_df #saving the results

#RESPIRATION
result_df <- NULL

# Loop for respiration
for (i in pairs){
  currentpair = filter(p_data,group_condition==i)
  Results=crqa(currentpair$Resp1, currentpair$Resp2, delay=delayResp, embed=emddimResp, radius=radiusResp, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df <- data_frame(group_trial = unique(currentpair$group_condition),study = unique(currentpair$study),group = unique(currentpair$group),trial = unique(currentpair$trial),condition = unique(currentpair$condition), RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)
  # study = currentpair$study,group = currentpair$group, trial = currentpair$trial, condition = currentpair$condition, 
if (i == 1){
    result_df <- temp_df
  } else {
    result_df <- rbind(result_df, temp_df)
  }
}

result_real_Resp <- result_df

#writing csv
write.csv(result_real_Resp, "result_real_Resp.csv")
write.csv(result_real_HR, "result_real_HR.csv")


```


### Creating controls: shuffled controls
 - loop through all pairs and conditions
 - shuffle the timeseries (take a timeseries and rearrange its values in a random order). Tip check the sample() function
 - run crqa and save the output. NB. which delay, embed, radius parameters should you use?
 - statistically compare the crqa indexes in real and shuffled pairs

```{r crqa loop shuffled pairs, include = FALSE, eval = FALSE}
#HEARTRATE
result_df <- NULL

for (i in pairs){
  currentpair = filter(p_data,group_condition==i)
  Results=crqa(sample(currentpair$HR1), sample(currentpair$HR2), delay=delayHR, embed=emddimHR, radius=radiusHR, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df <- data_frame(group_trial = unique(currentpair$group_condition),study = unique(currentpair$study),group = unique(currentpair$group),trial = unique(currentpair$trial),condition = unique(currentpair$condition), RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)
  # study = currentpair$study,group = currentpair$group, trial = currentpair$trial, condition = currentpair$condition, 
if (i == 1){
    result_df <- temp_df
  } else {
    result_df <- rbind(result_df, temp_df)
  }
}
result_shuffled_HR <- result_df


#RESPIRATION
result_df <- NULL

for (i in pairs){
  currentpair = filter(p_data,group_condition==i)
  Results=crqa(sample(currentpair$Resp1), sample(currentpair$Resp2), delay=delayResp, embed=emddimResp, radius=radiusResp, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df <- data_frame(group_trial = unique(currentpair$group_condition),study = unique(currentpair$study),group = unique(currentpair$group),trial = unique(currentpair$trial),condition = unique(currentpair$condition), RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)
  # study = currentpair$study,group = currentpair$group, trial = currentpair$trial, condition = currentpair$condition, 
if (i == 1){
    result_df <- temp_df
  } else {
    result_df <- rbind(result_df, temp_df)
  }
}

result_shuffled_Resp <- result_df

#making a csv
write.csv(result_real_Resp, "result_shuffled_Resp.csv")
write.csv(result_real_Resp, "result_shuffled_HR.csv")

```

```{r statistic comparison for shuffled and real pairs, include = FALSE, eval = FALSE}

#Creating  column defining pair type
result_real_HR <- mutate(result_real_HR, pair_type = 'real')
result_real_Resp <- mutate(result_real_Resp, pair_type = 'real')

result_shuffled_HR <- mutate(result_shuffled_HR, pair_type = 'shuffled')
result_shuffled_Resp <- mutate(result_shuffled_Resp, pair_type = 'shuffled')

results_real_shuffled_HR <- rbind(result_real_HR, result_shuffled_HR)
results_real_shuffled_Resp <- rbind(result_real_Resp, result_shuffled_Resp)

#model testing if there is a difference between real and shuffled pairs

#HR
model_real_shuffled_RR = lm(RR ~pair_type+trial, data = results_real_shuffled_HR)
summary(model_real_shuffled_RR)

model_real_shuffled_L = lm(L ~pair_type+trial, data = results_real_shuffled_HR)
summary(model_real_shuffled_L)

model_real_shuffled_DET = lm(DET ~pair_type+trial, data = results_real_shuffled_HR)
summary(model_real_shuffled_DET)

#RESP
model_real_shuffled_RR = lm(RR ~pair_type+trial, data = results_real_shuffled_Resp)
summary(model_real_shuffled_RR)

model_real_shuffled_L = lm(L ~pair_type+trial, data = results_real_shuffled_Resp)
summary(model_real_shuffled_L)

model_real_shuffled_DET = lm(DET ~pair_type+trial, data = results_real_shuffled_Resp)
summary(model_real_shuffled_DET)
```


```{r plotting real and shuffled pairs, include = FALSE, echo = FALSE, eval = FALSE}
plot1 <- ggplot(results_real_shuffled_Resp, aes(x=pair_type, y=L)) +
  geom_bar(stat = "summary", fun.y = mean, aes(fill = pair_type))
plot2 <- ggplot(results_real_shuffled_Resp, aes(x=pair_type, y=DET)) +
  geom_bar(stat = "summary", fun.y = mean, aes(fill = pair_type))
plot3 <- ggplot(results_real_shuffled_Resp, aes(x=pair_type, y=RR)) +
  geom_quasi(stat = "summary", fun.y = mean, aes(fill = pair_type))

plot_Resp_real_shuffled <- grid.arrange(plot1,plot2,plot3)

```


### TRICKY! Creating controls: surrogate pair controls
 - Per each real pair, identify at least one surrogate pair (matching one of the participants, with somebody doing the same task, but in a different pair). Tip: Malte will share a method to do this on screen.
 - Run crqa on all the surrogate pairs and save the output. NB. which delay, embed, radius parameters should you use?
 - Test whether crqa shows a difference between real and surrogate pairs
 
 
```{r crqa loop surrogate pairs, include = FALSE, eval = FALSE}
#transforming to long format
data_long <- gather(p_data, InterlocutorResp, Resp_measurement, Resp1:Resp2, factor_key=TRUE)
data_long <- gather(data_long, InterlocutorHR, HR_measurement, HR1:HR2, factor_key=TRUE)

#making an extra unique group and and condition
data_long <- data_long %>%
  mutate(group_HR = str_c(group, InterlocutorHR, sep = " "))

data_long <- data_long %>%
  mutate(group_Resp = str_c(group, InterlocutorResp, sep = " "))

#split data into conditions
data_long_S <- filter(data_long, condition =="Synchronous")
data_long_TT <- filter(data_long, condition == "TurnTaking")
data_long_C <- filter(data_long, condition =="Conversation")

#create combinations
participants <- as.numeric(unlist(purrr::map(unique(data_long$group), ~str_c(., c(1,2)))))
combinations = expand.grid(p1 = participants, p2 = participants) %>% filter(p1 > p2)
combinations


#looping through combinations per condition
#HR in condition synchrounous
result_surrogate_HR_S <- NULL

for (i in 1:length(combinations[,1])){
  Respondent1 = as.character(combinations[i,1])
  g1 = as.numeric(str_sub(Respondent1, 0, -2))
  p1 = str_sub(Respondent1, -1)
  Respondent1data = filter(data_long_S, group == g1, InterlocutorHR == str_c("HR", p1))
  Respondent2 = as.character(combinations[i,2])
  g2 = as.numeric(str_sub(Respondent1, 0, -2))
    p2 = str_sub(Respondent2, -1)
  Respondent2data = filter(data_long_S, group == g2, InterlocutorHR == str_c("HR", p2))
  print(g1)
  if(nrow(Respondent1data) == 0 | nrow(Respondent2data) == 0) next
  Results=crqa(Respondent1data$HR_measurement, Respondent2data$HR_measurement, delay=delayHR, embed=emddimHR, radius=radiusHR, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df <- data_frame(Respondent1 = Respondent1,Respondent2=Respondent2, RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)
if (i == 1){
    result_surrogate_HR_S <- temp_df
  } else {
    result_surrogate_HR_S <- rbind(result_surrogate_HR_S, temp_df)
  }
}

#Heartrate turntaking
result_surrogate_HR_TT <- NULL

for (i in 1:length(combinations[,1])){
  Respondent1 = as.character(combinations[i,1])
  g1 = as.numeric(str_sub(Respondent1, 0, -2))
  p1 = str_sub(Respondent1, -1)
  Respondent1data = filter(data_long_TT, group == g1, InterlocutorHR == str_c("HR", p1))
  Respondent2 = as.character(combinations[i,2])
  g2 = as.numeric(str_sub(Respondent1, 0, -2))
    p2 = str_sub(Respondent2, -1)
  Respondent2data = filter(data_long_TT, group == g2, InterlocutorHR == str_c("HR", p2))
  print(g1)
  if(nrow(Respondent1data) == 0 | nrow(Respondent2data) == 0) next
  Results=crqa(Respondent1data$HR_measurement, Respondent2data$HR_measurement, delay=delayHR, embed=emddimHR, radius=radiusHR, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df <- data_frame(Respondent1 = Respondent1,Respondent2=Respondent2, RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)
if (i == 1){
    result_surrogate_HR_TT <- temp_df
  } else {
    result_surrogate_HR_TT <- rbind(result_surrogate_HR_TT, temp_df)
  }
}

#Heartrate conversation
result_surrogate_HR_C <- NULL

for (i in 1:length(combinations[,1])){
  Respondent1 = as.character(combinations[i,1])
  g1 = as.numeric(str_sub(Respondent1, 0, -2))
  p1 = str_sub(Respondent1, -1)
  Respondent1data = filter(data_long_C, group == g1, InterlocutorHR == str_c("HR", p1))
  Respondent2 = as.character(combinations[i,2])
  g2 = as.numeric(str_sub(Respondent1, 0, -2))
    p2 = str_sub(Respondent2, -1)
  Respondent2data = filter(data_long_C, group == g2, InterlocutorHR == str_c("HR", p2))
  print(g1)
  if(nrow(Respondent1data) == 0 | nrow(Respondent2data) == 0) next
  Results=crqa(Respondent1data$HR_measurement, Respondent2data$HR_measurement, delay=delayHR, embed=emddimHR, radius=radiusHR, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df <- data_frame(Respondent1 = Respondent1,Respondent2=Respondent2, RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)
if (i == 1){
    result_surrogate_HR_C <- temp_df
  } else {
    result_surrogate_HR_C <- rbind(result_surrogate_HR_C, temp_df)
  }
}

#Respiration synchronous

result_surrogate_Resp_S <- NULL

for (i in 1:length(combinations[,1])){
  Respondent1 = as.character(combinations[i,1])
  g1 = as.numeric(str_sub(Respondent1, 0, -2))
  p1 = str_sub(Respondent1, -1)
  Respondent1data = filter(data_long_S, group == g1, InterlocutorResp == str_c("Resp", p1))
  Respondent2 = as.character(combinations[i,2])
  g2 = as.numeric(str_sub(Respondent1, 0, -2))
    p2 = str_sub(Respondent2, -1)
  Respondent2data = filter(data_long_S, group == g2, InterlocutorResp == str_c("Resp", p2))
  print(g1)
  if(nrow(Respondent1data) == 0 | nrow(Respondent2data) == 0) next
  Results=crqa(Respondent1data$Resp_measurement, Respondent2data$Resp_measurement, delay=delayResp, embed=emddimResp, radius=radiusResp, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df <- data_frame(Respondent1 = Respondent1,Respondent2=Respondent2, RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)
if (i == 1){
    result_surrogate_Resp_S <- temp_df
  } else {
    result_surrogate_Resp_S <- rbind(result_surrogate_Resp_S, temp_df)
  }
}

#Respiration Turntaking
result_surrogate_Resp_TT <- NULL

for (i in 1:length(combinations[,1])){
  Respondent1 = as.character(combinations[i,1])
  g1 = as.numeric(str_sub(Respondent1, 0, -2))
  p1 = str_sub(Respondent1, -1)
  Respondent1data = filter(data_long_TT, group == g1, InterlocutorResp == str_c("Resp", p1))
  Respondent2 = as.character(combinations[i,2])
  g2 = as.numeric(str_sub(Respondent1, 0, -2))
    p2 = str_sub(Respondent2, -1)
  Respondent2data = filter(data_long_TT, group == g2, InterlocutorResp == str_c("Resp", p2))
  print(g1)
  if(nrow(Respondent1data) == 0 | nrow(Respondent2data) == 0) next
  Results=crqa(Respondent1data$Resp_measurement, Respondent2data$Resp_measurement, delay=delayResp, embed=emddimResp, radius=radiusResp, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df <- data_frame(Respondent1 = Respondent1,Respondent2=Respondent2, RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)
if (i == 1){
    result_surrogate_Resp_TT <- temp_df
  } else {
    result_surrogate_Resp_TT <- rbind(result_surrogate_Resp_TT, temp_df)
  }
}
#Respiration conversation

result_surrogate_Resp_C <- NULL

for (i in 1:length(combinations[,1])){
  Respondent1 = as.character(combinations[i,1])
  g1 = as.numeric(str_sub(Respondent1, 0, -2))
  p1 = str_sub(Respondent1, -1)
  Respondent1data = filter(data_long_C, group == g1, InterlocutorResp == str_c("Resp", p1))
  Respondent2 = as.character(combinations[i,2])
  g2 = as.numeric(str_sub(Respondent1, 0, -2))
    p2 = str_sub(Respondent2, -1)
  Respondent2data = filter(data_long_C, group == g2, InterlocutorResp == str_c("Resp", p2))
  print(g1)
  if(nrow(Respondent1data) == 0 | nrow(Respondent2data) == 0) next
  Results=crqa(Respondent1data$Resp_measurement, Respondent2data$Resp_measurement, delay=delayResp, embed=emddimResp, radius=radiusResp, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df <- data_frame(Respondent1 = Respondent1,Respondent2=Respondent2, RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)
if (i == 1){
    result_surrogate_Resp_C <- temp_df
  } else {
    result_surrogate_Resp_C <- rbind(result_surrogate_Resp_C, temp_df)
  }
}
```

```{r testing difference between real and surrogate pairs, include = FALSE, eval = FALSE}

#make a column telling condition and pair type
result_surrogate_HR_S <- mutate(result_surrogate_HR_S, condition = 'Synchronous')
result_surrogate_HR_TT <- mutate(result_surrogate_HR_TT, condition = 'TurnTaking')
result_surrogate_HR_C <- mutate(result_surrogate_HR_C, condition = 'Conversation')
result_surrogate_Resp_S <- mutate(result_surrogate_Resp_S, condition = 'Synchronous')
result_surrogate_Resp_TT <- mutate(result_surrogate_Resp_TT, condition = 'TurnTaking')
result_surrogate_Resp_C <- mutate(result_surrogate_Resp_C, condition = 'Conversation')


result_surrogate_HR_S <- mutate(result_surrogate_HR_S, pair_type = 'surrogate')
result_surrogate_HR_TT <- mutate(result_surrogate_HR_TT, pair_type = 'surrogate')
result_surrogate_HR_C <- mutate(result_surrogate_HR_C, pair_type = 'surrogate')
result_surrogate_Resp_S <- mutate(result_surrogate_Resp_S, pair_type = 'surrogate')
result_surrogate_Resp_TT <- mutate(result_surrogate_Resp_TT, pair_type = 'surrogate')
result_surrogate_Resp_C <- mutate(result_surrogate_Resp_C, pair_type = 'surrogate')

#merge real, shuffled and surrogate pairs in one df for HR and respiration
crqa_results_HR <- rbind(result_surrogate_HR_S[3:13], result_surrogate_HR_TT[3:13], result_surrogate_HR_C[3:13], result_real_HR[5:15], result_shuffled_HR[5:15])
crqa_results_Resp <- rbind(result_surrogate_Resp_S[3:13], result_surrogate_Resp_TT[3:13], result_surrogate_Resp_C[3:13], result_real_Resp[5:15], result_shuffled_Resp[5:15])


#write csv
#write.csv(crqa_results_HR, file = "crqa_results_HR.csv")
#write.csv(crqa_results_Resp, file = "crqa_results_Resp.csv")

#HR
modelRR_HR = lm(RR ~ pair_type, data = crqa_results_HR)
summary(modelRR_HR)

modelL_HR = lm(L ~ pair_type, data = crqa_results_HR)
summary(modelL_HR)

modelDET_HR = lm(DET ~ pair_type, data = crqa_results_HR)
summary(modelDET_HR) #not significant

#Resp
modelRR_Resp = lm(RR ~  pair_type, data = crqa_results_Resp)
summary(modelRR_Resp)

modelL_Resp = lm(L ~  pair_type, data = crqa_results_Resp)
summary(modelL_Resp) #not significant

modelDET_Resp = lm(DET ~ pair_type, data = crqa_results_Resp)
summary(modelDET_Resp) #not significant
```


```{r plotting the difference bewteen real and surrogate pairs, include = FALSE, echo = FALSE}

```


### Testing effects of conditions
 - make a (probably underpowered) mixed model testing effects of the different conditions on heart rate and respiration coordination
 - N.B: would it make sense to include surrogate pairs? and if so how? what would that tell you?
 
```{r testing the effect of condition, include = FALSE, eval = FALSE}

#making a model
modelRR_HR = lm(RR ~ condition * pair_type, data = crqa_results_HR)
summary(modelRR_HR)

modelL_HR = lm(L ~ condition * pair_type, data = crqa_results_HR)
summary(modelL_HR)

modelDET_HR = lm(DET ~ condition*pair_type, data = crqa_results_HR)
summary(modelDET_HR)

#making a model
modelRR_Resp = lm(RR ~ condition * pair_type, data = crqa_results_Resp)
summary(modelRR_Resp)

modelL_Resp = lm(L ~ condition * pair_type, data = crqa_results_Resp)
summary(modelL)

modelDET_Resp = lm(DET ~ condition*pair_type, data = crqa_results_Resp)
summary(modelDET)

```

### Effects of respiration coordination on heart rate coordination
 - describe how you would test those.
 - Optional: run the models and report them
 
 

```{r testing, include = FALSE, eval = FALSE}
 #can coordination in respiration predict coordination in heartrate
HR ~ 
```

 
 
```{r things I wish would work, eval = FALSE, include = FALSE}

#turn into long format, create two new variables (participant and HR), and add down.HR1 and down.HR2 in those two
HR = gather(p_data, "participant", "HR", HR1, HR2) %>%
  mutate(participant = str_extract(participant, "\\d+")) %>% #use only digit in participant column
  select(-Resp1, -Resp2) #deselect columns 

#same as with HR
resp = gather(p_data, "participant", "Resp", Resp1, Resp2) %>%
  mutate(participant = str_extract(participant, "\\d+")) %>% 
  select(-HR1, -HR2)

#new dataframe, join HR and resp dataframes
surrogate_data = full_join(HR, resp) %>%
  mutate(participant = str_c(group, participant)) #create variable to have unique combination of groups and participant
  
#take all the unique combinations
participants = unique(surrogate_data$participant)

#divide the data according to conditions
surrogateS <- filter(surrogate_data, condition =="Synchronous")
#data_long_TT <- filter(surrogate_data, condition == "TurnTaking")
#data_long_SC <- filter(surrogate_data, condition == "SelfPaced"|condition =="Conversation")

#shuffle all possible combinations of participants
combination = expand.grid(p1 = participants, p2 = participants) %>%
  dplyr::filter(p1 != p2)

combination

fit_surrogate <- function(p1, p2) {
  hr1 = filter(surrogate_data, participant == p1)
  hr2 = filter(surrogate_data, participant == p2)
  Results=crqa(hr1$HR, hr2$HR, delay=delay, embed=emddim, radius=radius, normalize=0 ,rescale=0 , mindiagline = 2 ,minvertline = 2)
  temp_df = c(p1 = p1, p2 = p2, RR = Results$RR, DET = Results$DET, NRLINE = Results$NRLINE, LMAX = Results$maxL, L = Results$L,ENTR = Results$ENTR, rENTR = Results$rENTR, LAM = Results$LAM, TT = Results$TT)  
  if (p1== 21 & p2 ==11){
    result_df <- temp_df
  } else {
    result_df <- rbind(result_df, temp_df)
  }
  return(result_df)
  }

surrogate_results = map2_df(c(combination[1]), c(combination[2]), fit_surrogate)
```
